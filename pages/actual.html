---
layout: default
title: Actual Deck
permalink: /actual/
---

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Actual Deck</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root {
    color-scheme: light;
    font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    --surface: #f4f4f5;
    --ink: #0f172a;
    --outline: #131b2b;
    --card-color: #1f2937;
    --card-color-accent: #475569;
    --card-color-pastel: #e2e8f0;
  }

  body {
    background: var(--surface);
    color: var(--ink);
  }

  main {
    position: relative;
    padding-bottom: 8rem;
  }

  .card {
    perspective: 1600px;
  }

  .card-inner {
    position: relative;
    transform-style: preserve-3d;
    transition: transform .6s ease;
  }

  .card[data-flipped="1"] .card-inner {
    transform: rotateY(180deg);
  }

  .card-surface {
    position: relative;
    backface-visibility: hidden;
    border-radius: 1rem;
    --card-padding: 1.1rem;
    padding: var(--card-padding);
    min-height: 15rem;
    border: 1px solid rgba(15, 23, 42, 0.1);
    background: #ffffff;
    box-shadow: 0 18px 42px rgba(15, 23, 42, 0.14);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    overflow: hidden;
    width: 100%;
    transition: transform .18s ease, box-shadow .18s ease;
  }

  .card-surface:hover {
    transform: translateY(-3px);
    box-shadow: 0 26px 56px rgba(15, 23, 42, 0.18);
  }

  .card-front,
  .card-back {
    background: #ffffff;
    color: var(--ink);
  }

  .card-front .card-header,
  .card-back .card-header {
    margin: calc(var(--card-padding) * -1);
    margin-bottom: 1rem;
    padding: .85rem var(--card-padding);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-top-left-radius: 1.25rem;
    border-top-right-radius: 1.25rem;
  }

  .card-front .card-header {
    background: var(--card-color, #1f2937);
    color: #f8fafc;
    border-bottom: 1px solid rgba(248, 250, 252, 0.35);
  }

  .card-front .card-header .card-id {
    color: rgba(248, 250, 252, 0.7);
  }

  .card-back .card-header {
    background: var(--card-color-pastel, #e2e8f0);
    color: var(--card-color, var(--ink));
    border-bottom: 1px solid rgba(15, 23, 42, 0.08);
  }

  .card-back .card-header .card-id {
    color: rgba(15, 23, 42, 0.55);
  }

  .presentation-face.card-front .card-header,
  .presentation-face.card-back .card-header {
    margin: calc(var(--card-padding) * -1);
    margin-bottom: 1.6rem;
    padding: 1.1rem var(--card-padding);
  }

  .card-front .card-front-body {
    display: flex;
    flex-direction: column;
    gap: 1.1rem;
  }

  .card-front-content {
    display: flex;
    flex-direction: column;
    gap: .85rem;
  }

  .card-title {
    font-size: clamp(1.15rem, 2.4vw, 1.6rem);
    font-weight: 700;
    letter-spacing: -.01em;
    line-height: 1.25;
    color: inherit;
    margin: 0;
  }

  .card-summary,
  .card-quote,
  .card-author {
    margin: 0;
  }

  .card-summary {
    font-size: .92rem;
    line-height: 1.55;
    color: #1f2937;
    overflow-wrap: anywhere;
  }

  .card-quote {
    position: relative;
    padding-left: 1.1rem;
    color: #1f2937;
    font-style: italic;
    line-height: 1.55;
    overflow-wrap: anywhere;
  }

  .card-quote::before {
    content: "“";
    font-size: 1.8rem;
    position: absolute;
    left: 0;
    top: -.6rem;
    color: rgba(15, 23, 42, 0.16);
  }

  .card-author {
    font-size: .75rem;
    color: #475569;
  }

  .card-front .card-footer {
    border-top: 1px solid rgba(15, 23, 42, 0.1);
    padding-top: .85rem;
    margin-top: auto;
  }

  .card-front .card-id {
    color: #64748b;
  }

  .face.back {
    transform: rotateY(180deg);
    position: absolute;
    inset: 0;
  }

  .card[data-in-stack="1"] .card-surface {
    box-shadow: 0 30px 55px rgba(37, 99, 235, 0.28);
  }

  .card[data-highlight="1"] .card-surface {
    outline: 4px solid rgba(56, 189, 248, 0.85);
    outline-offset: -6px;
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .type-ribbon {
    display: inline-flex;
    align-items: center;
    padding: .28rem .85rem;
    border-radius: 9999px;
    text-transform: uppercase;
    font-size: .64rem;
    font-weight: 700;
    letter-spacing: .18em;
    background: transparent;
    color: inherit;
    border: 1px solid currentColor;
  }

  .card-controls {
    display: flex;
    gap: .5rem;
    flex-wrap: wrap;
  }

  .flip-btn,
  .stack-btn,
  .dialog-btn,
  .stack-panel button {
    border-radius: 9999px;
    border: none;
    padding: .32rem .95rem;
    background: rgba(248, 250, 252, 0.9);
    font-size: .7rem;
    font-weight: 600;
    letter-spacing: .06em;
    text-transform: uppercase;
    color: #0f172a;
    transition: transform .15s ease, box-shadow .15s ease, background-color .15s ease;
    cursor: pointer;
  }

  .flip-btn:hover,
  .stack-btn:hover,
  .dialog-btn:hover,
  .stack-panel button:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 18px rgba(15, 23, 42, 0.16);
    background: rgba(248, 250, 252, 1);
  }

  .stack-btn[data-active="1"] {
    background: rgba(248, 250, 252, 0.6);
  }

  .stack-card button:hover {
    background: rgba(15, 23, 42, 0.12);
    box-shadow: none;
    transform: none;
  }

  .card-footer {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: .6rem;
  }

  .card-id {
    font-size: .66rem;
    letter-spacing: .14em;
    text-transform: uppercase;
    color: #475569;
  }

  .card-footer .card-id {
    margin-left: auto;
  }

  .tag-list {
    display: flex;
    flex-wrap: wrap;
    gap: .4rem;
  }

  .tag {
    background: rgba(15, 23, 42, 0.08);
    border-radius: 9999px;
    padding: .2rem .68rem;
    font-size: .66rem;
    font-weight: 600;
    color: #0f172a;
    cursor: pointer;
    transition: transform .15s ease, box-shadow .15s ease, background-color .15s ease;
  }

  .tag:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 18px rgba(15, 23, 42, 0.16);
    background: rgba(15, 23, 42, 0.14);
  }

  .card-front .type-ribbon {
    background: rgba(248, 250, 252, 0.18);
    border-color: rgba(248, 250, 252, 0.4);
    color: #f8fafc;
  }

  .card-back .type-ribbon {
    background: rgba(15, 23, 42, 0.08);
    border-color: transparent;
    color: var(--card-color, #0f172a);
  }

  .card-back h3.card-back-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--card-color, var(--ink));
    letter-spacing: -.01em;
    line-height: 1.3;
    margin: 0;
    overflow-wrap: anywhere;
  }

  .card-back-body {
    display: flex;
    flex-direction: column;
    gap: .9rem;
  }

  .card-section {
    margin-top: .75rem;
    padding: .85rem .95rem;
    border-radius: .75rem;
    border: 1px solid var(--card-color-pastel, rgba(15, 23, 42, 0.12));
    background: rgba(248, 250, 252, 0.75);
  }

  .card-section-title {
    font-size: .68rem;
    text-transform: uppercase;
    letter-spacing: .18em;
    color: var(--card-color, #1f2937);
    font-weight: 700;
    margin-bottom: .45rem;
  }

  .card-section-list {
    list-style: decimal;
    padding-left: 1.2rem;
    color: var(--ink);
    line-height: 1.55;
    margin: 0;
  }

  .card-section-list li {
    margin-bottom: .35rem;
    overflow-wrap: anywhere;
  }

  .card-section-text {
    color: var(--ink);
    line-height: 1.55;
    margin: 0;
    overflow-wrap: anywhere;
    font-size: .9rem;
  }

  .card-empty-note {
    font-size: .82rem;
    color: #64748b;
    font-style: italic;
  }

  .stack-dock {
    position: sticky;
    bottom: 1.5rem;
    z-index: 30;
  }

  .stack-panel {
    border: 1px solid rgba(15, 23, 42, 0.12);
    border-radius: 1.25rem;
    padding: 1.5rem;
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 18px 36px rgba(15, 23, 42, 0.18);
    backdrop-filter: blur(6px);
  }

  #stack-list {
    max-height: min(40vh, 24rem);
    overflow-y: auto;
    padding-right: .25rem;
  }

  .stack-card {
    border-radius: 1rem;
    border: 1px solid rgba(15, 23, 42, 0.12);
    background: linear-gradient(135deg, rgba(248, 250, 252, 0.96), var(--card-color-pastel, #e2e8f0));
    padding: .9rem;
    display: flex;
    gap: .85rem;
    align-items: flex-start;
    border-left: 4px solid var(--card-color, rgba(15, 23, 42, 0.16));
  }

  .stack-card button {
    padding: .25rem .6rem;
    border-radius: .6rem;
    border: none;
    background: rgba(15, 23, 42, 0.08);
    font-size: .65rem;
    letter-spacing: .1em;
    text-transform: uppercase;
    font-weight: 600;
    color: #0f172a;
  }

  .stack-card button:disabled {
    opacity: .35;
    cursor: not-allowed;
  }

  .stack-card-main {
    flex: 1;
    cursor: pointer;
  }

  .stack-card-actions {
    display: flex;
    flex-direction: column;
    gap: .35rem;
  }

  .stack-meta {
    font-size: .74rem;
    color: #475569;
    text-transform: uppercase;
    letter-spacing: .12em;
  }

  .stack-empty {
    font-size: .85rem;
    color: #475569;
    font-style: italic;
  }

  .presentation-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(15, 23, 42, 0.82);
    z-index: 50;
    padding: 1.5rem;
  }

  .presentation-overlay[hidden] {
    display: none;
  }

  .presentation-dialog {
    background: #ffffff;
    border: 1px solid rgba(15, 23, 42, 0.16);
    border-radius: 1.5rem;
    width: 100%;
    max-width: 48rem;
    max-height: 100%;
    padding: 2.2rem;
    box-shadow: 0 32px 60px rgba(15, 23, 42, 0.35);
    display: flex;
    flex-direction: column;
    gap: 1.35rem;
  }

  .presentation-card {
    flex: 1;
    overflow: auto;
  }

  .presentation-controls {
    display: flex;
    gap: .6rem;
    justify-content: space-between;
    flex-wrap: wrap;
  }

  .presentation-face {
    display: flex;
    flex-direction: column;
    gap: 1.1rem;
    border-radius: 1.2rem;
    --card-padding: 1.4rem;
    padding: var(--card-padding);
    box-shadow: 0 32px 70px rgba(15, 23, 42, 0.32);
  }

  .presentation-face.card-back {
    border: 1px solid rgba(15, 23, 42, 0.16);
  }

  .presentation-face:hover {
    transform: none;
    box-shadow: 0 32px 70px rgba(15, 23, 42, 0.32);
  }

  .dialog-btn {
    border-radius: .75rem;
  }

  .card-back .card-section-list,
  .presentation-face .card-section-list {
    list-style: decimal;
  }

  .card-back .card-section-list li,
  .presentation-face .card-section-list li {
    margin-bottom: .35rem;
  }

  .card-back .card-section-text,
  .presentation-face .card-section-text {
    font-size: .88rem;
  }

  .tag:focus-visible,
  .flip-btn:focus-visible,
  .stack-btn:focus-visible,
  .dialog-btn:focus-visible,
  .stack-panel button:focus-visible {
    outline: 3px solid #2563eb;
    outline-offset: 2px;
  }
</style>
</head>
<body>
  <main class="max-w-6xl mx-auto px-4 py-8">
    <header class="mb-6 flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
      <div>
        <h1 class="text-2xl font-semibold">Actual Deck</h1>
        <p id="meta" class="text-sm text-slate-500">Loading…</p>
      </div>

      <div class="flex flex-col sm:flex-row gap-2 sm:items-center">
        <select id="preset" class="border rounded-lg px-3 py-2">
          <option value="">All cards</option>
        </select>
        <input id="q" type="search" placeholder="Search title, quote, tags"
               class="border rounded-lg px-3 py-2 w-full sm:w-64" />
        <button id="shuffle" class="dialog-btn">Shuffle</button>
      </div>
    </header>

    <section id="cards" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6"></section>

    <aside class="stack-dock mt-8">
      <div class="stack-panel space-y-4">
        <div>
          <h2 class="text-base font-semibold">Presentation stack</h2>
          <p id="stack-meta" class="stack-meta">No cards selected yet.</p>
        </div>
        <div id="stack-list" class="space-y-3"></div>
        <div class="flex gap-2 flex-wrap">
          <button id="stack-present" class="dialog-btn" disabled>Start presentation</button>
          <button id="stack-clear" class="dialog-btn" disabled>Clear</button>
        </div>
      </div>
    </aside>

    <aside class="stack-dock mt-8">
      <div class="stack-panel space-y-4">
        <div>
          <h2 class="text-base font-semibold">Presentation stack</h2>
          <p id="stack-meta" class="stack-meta">No cards selected yet.</p>
        </div>
        <div id="stack-list" class="space-y-3"></div>
        <div class="flex gap-2 flex-wrap">
          <button id="stack-present" class="dialog-btn" disabled>Start presentation</button>
          <button id="stack-clear" class="dialog-btn" disabled>Clear</button>
        </div>
      </div>
    </aside>

    <template id="card-tpl">
      <article class="card">
        <div class="card-inner">
          <!-- FRONT -->
          <div class="face front card-surface card-front">
            <header class="card-header">
              <span class="type-ribbon" data-family-pill></span>
              <div class="card-controls">
                <button class="stack-btn" data-stack>Add to stack</button>
                <button class="flip-btn" data-flip>Flip</button>
              </div>
            </header>
            <div class="card-front-body">
              <div class="card-front-content">
                <h2 class="card-title" data-title></h2>
                <p class="card-summary" data-summary></p>
                <blockquote class="card-quote" data-quote></blockquote>
                <p class="card-author" data-author></p>
              </div>
            </div>
            <footer class="card-footer">
              <div class="tag-list" data-tags></div>
              <span class="card-id" data-id></span>
            </footer>
          </div>

          <!-- BACK -->
          <div class="face back card-surface card-back">
            <header class="card-header">
              <span class="type-ribbon" data-family-pill-back></span>
              <button class="flip-btn" data-flip>Flip</button>
            </header>
            <h3 class="card-back-title" data-title-back></h3>
            <div class="card-back-body" data-back></div>
          </div>
        </div>
      </article>
    </template>
  </main>

  <div id="presentation" class="presentation-overlay" hidden>
    <div class="presentation-dialog" role="dialog" aria-modal="true" aria-labelledby="presentation-title">
      <div class="flex items-start justify-between gap-4">
        <div>
          <h2 id="presentation-title" class="text-lg font-semibold">Presentation mode</h2>
          <p id="presentation-meta" class="stack-meta"></p>
        </div>
        <button id="presentation-close" class="dialog-btn">Close</button>
      </div>
      <div id="presentation-card" class="presentation-card"></div>
      <div class="presentation-controls">
        <div class="flex gap-2">
          <button id="presentation-prev" class="dialog-btn">Previous</button>
          <button id="presentation-next" class="dialog-btn">Next</button>
        </div>
        <div class="flex gap-2">
          <button id="presentation-flip" class="dialog-btn">Flip card</button>
        </div>
      </div>
    </div>
  </div>

<script>
  // Config
  const JSON_BASE = "/data/actual-deck";
  const CARDS_URL = `${JSON_BASE}/cards.json`;
  const PRESETS_URL = `${JSON_BASE}/presets.json`;

  // Simple color map by type/family
  const TYPE_COLORS = {
    automation: "#c2410c",
    conviviality: "#047857",
    design: "#1f2937",
    flow: "#0ea5e9",
    language: "#1d4ed8",
    mechanism: "#7c3aed",
    metric: "#0f172a",
    outcome: "#4338ca",
    truth: "#b45309",
    vision: "#0369a1",
  };
  const DEFAULT_COLOR = "#334155";

  // State
  let ALL_CARDS = [];
  let PRESETS = [];
  let CURRENT = [];
  let STACK = [];
  const STACK_KEY = "actualDeckStack";
  let presentationIndex = 0;
  let presentationFlipped = false;
  const highlightTimers = new Map();

  // Elements
  const elCards   = document.getElementById("cards");
  const elPreset  = document.getElementById("preset");
  const elQ       = document.getElementById("q");
  const elMeta    = document.getElementById("meta");
  const elTpl     = document.getElementById("card-tpl");
  const elShuffle = document.getElementById("shuffle");
  const elStackList   = document.getElementById("stack-list");
  const elStackMeta   = document.getElementById("stack-meta");
  const elStackPresent= document.getElementById("stack-present");
  const elStackClear  = document.getElementById("stack-clear");
  const elPresentation      = document.getElementById("presentation");
  const elPresentationMeta  = document.getElementById("presentation-meta");
  const elPresentationCard  = document.getElementById("presentation-card");
  const elPresentationPrev  = document.getElementById("presentation-prev");
  const elPresentationNext  = document.getElementById("presentation-next");
  const elPresentationFlip  = document.getElementById("presentation-flip");
  const elPresentationClose = document.getElementById("presentation-close");
  const qs = new URLSearchParams(location.search);
  const cb = Date.now();

  async function fetchJSON(url){ const r=await fetch(`${url}?cb=${cb}`); if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }
  function normalize(s){ return (s||"").toLowerCase(); }
  function pickColor(family){
    const key = normalize(family||"");
    return TYPE_COLORS[key] || DEFAULT_COLOR;
  }
  function parseHexColor(value){
    if (typeof value !== "string") return null;
    const match = value.trim().match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
    if (!match) return null;
    let hex = match[1];
    if (hex.length === 3){
      hex = hex.split("").map(ch => ch + ch).join("");
    }
    const num = parseInt(hex, 16);
    return {
      r: (num >> 16) & 255,
      g: (num >> 8) & 255,
      b: num & 255,
    };
  }
  function mixWithWhite(hex, ratio = 0.5){
    const rgb = parseHexColor(hex);
    if (!rgb) return hex;
    const amount = Math.min(Math.max(ratio, 0), 1);
    const blend = (channel) => Math.round(channel + (255 - channel) * amount);
    return `rgb(${blend(rgb.r)}, ${blend(rgb.g)}, ${blend(rgb.b)})`;
  }
  function setCardColors(element, color){
    if (!element) return;
    element.style.setProperty("--card-color", color);
    element.style.setProperty("--card-color-accent", mixWithWhite(color, 0.3));
    element.style.setProperty("--card-color-pastel", mixWithWhite(color, 0.82));
  }
  function cardDomId(id){
    if (!id && id !== 0) return "";
    return `card-${String(id).trim().replace(/[^a-zA-Z0-9_-]+/g, "-").toLowerCase()}`;
  }
  function normalizeId(id){
    if (!id && id !== 0) return null;
    return typeof id === "string" ? id : String(id);
  }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function getCardById(id){
    const key = normalizeId(id);
    if (key === null) return undefined;
    return ALL_CARDS.find(c => normalizeId(c.id) === key);
  }
  function normalizeList(items){
    if (!Array.isArray(items)) return [];
    return items
      .map(item => {
        if (item === null || item === undefined) return "";
        return String(item).trim();
      })
      .filter(Boolean);
  }

  function collectBackSections(card){
    const sections = [];

    const addText = (title, value) => {
      if (!value) return;
      const text = String(value).trim();
      if (!text) return;
      sections.push({ kind: "text", title, text });
    };

    const addList = (title, values) => {
      const items = normalizeList(values);
      if (!items.length) return;
      sections.push({ kind: "list", title, items });
    };

    addText("Why it matters", card.why);
    addList("How to act", card.how);
    addText("Reflection", card.reflection);
    addList("Related cards", card.related);
    addList("Audiences", card.audiences);

    if (!sections.length){
      const fallback = card.tagline || card.details || card.notes;
      addText("Details", fallback);
    }

    if (!sections.length){
      sections.push({ kind: "empty" });
    }

    return sections;
  }

  function buildBackHtml(card){
    return collectBackSections(card).map(section => {
      if (section.kind === "empty"){
        return `<p class="card-empty-note">No additional details for this card.</p>`;
      }

      const title = section.title ? `<h4 class="card-section-title">${escapeHtml(section.title)}</h4>` : "";
      let body = "";
      if (section.kind === "text"){
        body = `<p class=\"card-section-text\">${escapeHtml(section.text)}</p>`;
      }else if (section.kind === "list"){
        body = `<ul class=\"card-section-list\">${section.items.map(item => `<li>${escapeHtml(item)}</li>`).join("")}</ul>`;
      }

      return `
        <section class="card-section">
          ${title}
          ${body}
        </section>
      `;
    }).join("");
  }

  function renderBackContent(container, card){
    if (!container) return;

    const sections = collectBackSections(card);
    container.innerHTML = "";

    sections.forEach(section => {
      if (section.kind === "empty"){
        const empty = document.createElement("p");
        empty.className = "card-empty-note";
        empty.textContent = "No additional details for this card.";
        container.appendChild(empty);
        return;
      }

      const block = document.createElement("section");
      block.className = "card-section";

      if (section.title){
        const heading = document.createElement("h4");
        heading.className = "card-section-title";
        heading.textContent = section.title;
        block.appendChild(heading);
      }

      if (section.kind === "text"){
        const para = document.createElement("p");
        para.className = "card-section-text";
        para.textContent = section.text;
        block.appendChild(para);
      }else if (section.kind === "list"){
        const list = document.createElement("ul");
        list.className = "card-section-list";
        section.items.forEach(item => {
          const li = document.createElement("li");
          li.textContent = item;
          list.appendChild(li);
        });
        block.appendChild(list);
      }

      container.appendChild(block);
    });

    if (container.childElementCount){
      container.removeAttribute("hidden");
    }else{
      container.setAttribute("hidden", "");
    }
  }

  function summarizeCard(card){
    return card.tagline || card.why || card.reflection || "";
  }

  function setTextOrHide(element, value){
    if (!element) return;
    if (value){
      element.textContent = value;
      element.removeAttribute("hidden");
    }else{
      element.textContent = "";
      element.setAttribute("hidden", "");
    }
  }

  function loadStack(){
    if (typeof localStorage === "undefined") return;
    try{
      const raw = localStorage.getItem(STACK_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)){
        STACK = parsed.map(normalizeId).filter(id => id !== null);
      }
    }catch(err){
      console.warn("Failed to load stack", err);
    }
  }
  function saveStack(){
    if (typeof localStorage === "undefined") return;
    try{ localStorage.setItem(STACK_KEY, JSON.stringify(STACK)); }
    catch(err){ console.warn("Failed to save stack", err); }
  }
  function renderStack(){
    const unique = [];
    for (const id of STACK){
      if (id !== null && !unique.includes(id) && getCardById(id)) unique.push(id);
    }
    if (unique.length !== STACK.length){
      STACK = unique;
      saveStack();
    }

    elStackList.innerHTML = "";
    const hasCards = STACK.length > 0;
    elStackMeta.textContent = hasCards
      ? `Cards selected: ${STACK.length}`
      : "No cards selected yet.";
    elStackPresent.disabled = !hasCards;
    elStackClear.disabled = !hasCards;

    if (!hasCards){
      closePresentation();
      const p = document.createElement("p");
      p.className = "stack-empty";
      p.textContent = "Select cards to build your presentation stack.";
      elStackList.appendChild(p);
      return;
    }

    STACK.forEach((id, index) => {
      const storedId = id;
      const card = getCardById(storedId);
      if (!card) return;

      const item = document.createElement("div");
      item.className = "stack-card";
      const color = pickColor(card.family || card.type);
      setCardColors(item, color);

      const main = document.createElement("div");
      main.className = "stack-card-main";
      const title = document.createElement("p");
      title.className = "text-sm font-medium";
      title.textContent = card.title || "(untitled)";
      const meta = document.createElement("p");
      meta.className = "text-xs text-slate-500";
      const metaBits = [card.family || card.type || "unspecified", card.id].filter(Boolean);
      meta.textContent = metaBits.join(" • ");
      main.appendChild(title);
      main.appendChild(meta);

      main.addEventListener("click", () => scrollToCard(storedId));

      const actions = document.createElement("div");
      actions.className = "stack-card-actions";

      function makeBtn(label, title){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = label;
        btn.title = title;
        btn.setAttribute("aria-label", title);
        return btn;
      }

      const presentBtn = makeBtn("▶", "Present from this card");
      presentBtn.addEventListener("click", (e) => { e.stopPropagation(); startPresentation(index); });

      const upBtn = makeBtn("↑", "Move up");
      upBtn.disabled = index === 0;
      upBtn.addEventListener("click", (e) => { e.stopPropagation(); moveStack(storedId, -1); });

      const downBtn = makeBtn("↓", "Move down");
      downBtn.disabled = index === STACK.length - 1;
      downBtn.addEventListener("click", (e) => { e.stopPropagation(); moveStack(storedId, 1); });

      const removeBtn = makeBtn("✕", "Remove from stack");
      removeBtn.addEventListener("click", (e) => { e.stopPropagation(); toggleStack(storedId); });

      actions.appendChild(presentBtn);
      actions.appendChild(upBtn);
      actions.appendChild(downBtn);
      actions.appendChild(removeBtn);

      item.appendChild(main);
      item.appendChild(actions);
      elStackList.appendChild(item);
    });

    if (!elPresentation.hasAttribute("hidden")){
      updatePresentation();
    }
  }
  function toggleStack(id){
    const key = normalizeId(id);
    if (key === null) return;
    const idx = STACK.indexOf(key);
    if (idx > -1){
      STACK.splice(idx, 1);
    }else{
      STACK.push(key);
    }
    renderStack();
    renderCards(CURRENT);
    saveStack();
  }
  function moveStack(id, dir){
    const key = normalizeId(id);
    if (key === null) return;
    const idx = STACK.indexOf(key);
    if (idx === -1) return;
    const next = idx + dir;
    if (next < 0 || next >= STACK.length) return;
    const [item] = STACK.splice(idx, 1);
    STACK.splice(next, 0, item);
    renderStack();
    saveStack();
  }
  function clearStack(){
    STACK = [];
    presentationIndex = 0;
    renderStack();
    renderCards(CURRENT);
    saveStack();
  }
  function startPresentation(index = 0){
    if (!STACK.length) return;
    presentationIndex = Math.min(Math.max(index, 0), STACK.length - 1);
    presentationFlipped = false;
    updatePresentation();
    elPresentation.removeAttribute("hidden");
    document.body.style.overflow = "hidden";
    document.addEventListener("keydown", handleKeydown);
  }
  function changePresentation(delta){
    if (!STACK.length) return;
    presentationIndex = Math.min(Math.max(presentationIndex + delta, 0), STACK.length - 1);
    presentationFlipped = false;
    updatePresentation();
  }
  function updatePresentation(){
    if (!STACK.length){
      closePresentation();
      return;
    }
    if (presentationIndex < 0) presentationIndex = 0;
    if (presentationIndex >= STACK.length) presentationIndex = STACK.length - 1;
    const id = STACK[presentationIndex];
    const card = getCardById(id);
    if (!card){
      STACK.splice(presentationIndex, 1);
      renderStack();
      saveStack();
      if (!STACK.length){
        closePresentation();
      }else{
        presentationIndex = Math.min(presentationIndex, STACK.length - 1);
        updatePresentation();
      }
      return;
    }

    const color = pickColor(card.family || card.type);
    const accent = mixWithWhite(color, 0.3);
    const pastel = mixWithWhite(color, 0.82);
    const styleVars = `--card-color:${color};--card-color-accent:${accent};--card-color-pastel:${pastel}`;
    const familyLabel = card.family || card.type || "unspecified";
    const cardIdText = card.id || card.id === 0 ? String(card.id) : "";
    const tagsHtml = (card.tags || []).map(t => `<span class="tag">${escapeHtml(t)}</span>`).join(" ");
    const summary = summarizeCard(card);
    const footerParts = [];
    if (tagsHtml) footerParts.push(`<div class="tag-list">${tagsHtml}</div>`);
    if (cardIdText) footerParts.push(`<span class="card-id">${escapeHtml(cardIdText)}</span>`);
    const footerHtml = footerParts.length ? `<footer class="card-footer">${footerParts.join("")}</footer>` : "";
    const frontHtml = `
      <article class="card-surface presentation-face card-front" style="${styleVars}">
        <header class="card-header">
          <span class="type-ribbon">${escapeHtml(familyLabel)}</span>
          ${cardIdText ? `<span class="card-id">${escapeHtml(cardIdText)}</span>` : ""}
        </header>
        <div class="card-front-body">
          <div class="card-front-content">
            <h3 class="card-title">${escapeHtml(card.title || "(untitled)")}</h3>
            ${summary ? `<p class="card-summary">${escapeHtml(summary)}</p>` : ""}
            ${card.quote ? `<blockquote class="card-quote">${escapeHtml(card.quote)}</blockquote>` : ""}
            ${card.author ? `<p class="card-author">— ${escapeHtml(card.author)}</p>` : ""}
          </div>
        </div>
        ${footerHtml}
      </article>
    `;
    const backHtml = `
      <article class="card-surface presentation-face card-back back" style="${styleVars}">
        <header class="card-header">
          <span class="type-ribbon">${escapeHtml(familyLabel)}</span>
          ${cardIdText ? `<span class="card-id">${escapeHtml(cardIdText)}</span>` : ""}
        </header>
        <h3 class="card-back-title">${escapeHtml(card.title || "(untitled)")}</h3>
        <div class="card-back-body">${buildBackHtml(card)}</div>
      </article>
    `;

    elPresentationCard.innerHTML = presentationFlipped ? backHtml : frontHtml;
    elPresentationCard.scrollTop = 0;
    elPresentationMeta.textContent = `Card ${presentationIndex + 1} of ${STACK.length}`;
    elPresentationPrev.disabled = presentationIndex === 0;
    elPresentationNext.disabled = presentationIndex >= STACK.length - 1;
    elPresentationFlip.textContent = presentationFlipped ? "Show front" : "Show back";
  }
  function closePresentation(){
    elPresentation.setAttribute("hidden", "");
    presentationFlipped = false;
    document.body.style.overflow = "";
    document.removeEventListener("keydown", handleKeydown);
  }
  function handleKeydown(event){
    if (elPresentation.hasAttribute("hidden")) return;
    if (event.key === "Escape"){
      closePresentation();
    }else if (event.key === "ArrowRight" || event.key === "PageDown"){
      event.preventDefault();
      changePresentation(1);
    }else if (event.key === "ArrowLeft" || event.key === "PageUp"){
      event.preventDefault();
      changePresentation(-1);
    }else if (event.key === " " || event.key === "Spacebar"){
      event.preventDefault();
      presentationFlipped = !presentationFlipped;
      updatePresentation();
    }
  }
  function scrollToCard(id){
    const key = normalizeId(id);
    if (key === null) return;
    const domId = cardDomId(key);
    if (!domId) return;
    const cardEl = document.getElementById(domId);
    if (!cardEl) return;
    cardEl.scrollIntoView({ behavior: "smooth", block: "center" });
    cardEl.setAttribute("data-highlight", "1");
    const existing = highlightTimers.get(domId);
    if (existing) clearTimeout(existing);
    const timeout = setTimeout(() => {
      cardEl.removeAttribute("data-highlight");
      highlightTimers.delete(domId);
    }, 1600);
    highlightTimers.set(domId, timeout);
  }

  let balanceFrame = null;

  function balanceCardHeights(){
    if (!elCards) return;
    const cards = elCards.querySelectorAll(".card");
    cards.forEach(card => {
      const inner = card.querySelector(".card-inner");
      const front = card.querySelector(".card-front");
      const back = card.querySelector(".card-back");
      if (!front || !back) return;

      front.style.minHeight = "";
      back.style.minHeight = "";
      if (inner) inner.style.minHeight = "";

      const frontMin = parseFloat(getComputedStyle(front).minHeight) || 0;
      const backMin = parseFloat(getComputedStyle(back).minHeight) || 0;
      const base = Math.max(frontMin, backMin);
      const target = Math.max(front.scrollHeight, back.scrollHeight, base);

      if (target > 0){
        front.style.minHeight = `${target}px`;
        back.style.minHeight = `${target}px`;
        if (inner) inner.style.minHeight = `${target}px`;
      }
    });
  }

  function scheduleCardBalance(){
    cancelAnimationFrame(balanceFrame);
    balanceFrame = requestAnimationFrame(() => {
      balanceFrame = null;
      balanceCardHeights();
    });
  }

  function renderCards(list){
    elCards.innerHTML = "";
    if(!list.length){ elCards.innerHTML = `<p class="text-slate-600">No cards match.</p>`; return; }

    const frag = document.createDocumentFragment();
    for(const c of list){
      const node = elTpl.content.cloneNode(true);
      const root = node.querySelector("article.card");
      const color = pickColor(c.family || c.type);
      const cardId = c.id;
      const normalizedId = normalizeId(cardId);
      setCardColors(root, color);
      if (normalizedId !== null){
        const domId = cardDomId(normalizedId);
        if (domId) root.id = domId;
      }
      root.removeAttribute("data-highlight");

      const inStack = normalizedId !== null ? STACK.includes(normalizedId) : false;
      root.setAttribute("data-in-stack", inStack ? "1" : "0");

      node.querySelector("[data-title]").textContent = c.title || "(untitled)";
      const idText = normalizedId !== null ? normalizedId : "";
      setTextOrHide(node.querySelector("[data-id]"), idText);
      setTextOrHide(node.querySelector("[data-summary]"), summarizeCard(c));
      setTextOrHide(node.querySelector("[data-quote]"), c.quote);
      setTextOrHide(node.querySelector("[data-author]"), c.author ? `— ${c.author}` : "");

      const pill = node.querySelector("[data-family-pill]");
      const familyLabel = c.family || c.type || "unspecified";
      if (pill) pill.textContent = familyLabel;
      const pillBack = node.querySelector("[data-family-pill-back]");
      if (pillBack) pillBack.textContent = familyLabel;
      const backTitle = node.querySelector("[data-title-back]");
      if (backTitle) backTitle.textContent = c.title || "(untitled)";

      const stackBtn = node.querySelector("[data-stack]");
      if (cardId || cardId === 0){
        stackBtn.textContent = inStack ? "Remove from stack" : "Add to stack";
        stackBtn.dataset.active = inStack ? "1" : "0";
        stackBtn.setAttribute("aria-pressed", inStack ? "true" : "false");
        stackBtn.disabled = false;
        stackBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleStack(cardId);
        });
      }else{
        stackBtn.disabled = true;
        stackBtn.dataset.active = "0";
        stackBtn.setAttribute("aria-pressed", "false");
        stackBtn.textContent = "No ID";
      }

      // Tags
      const tagsWrap = node.querySelector("[data-tags]");
      tagsWrap.innerHTML = "";
      (c.tags || []).forEach(t => {
        const s = document.createElement("span");
        s.className = "tag";
        s.textContent = t;
        s.dataset.tag = t;
        s.addEventListener("click", () => { elQ.value = t; applyFilters(); });
        tagsWrap.appendChild(s);
      });
      if (tagsWrap.childElementCount){
        tagsWrap.removeAttribute("hidden");
      }else{
        tagsWrap.setAttribute("hidden", "");
      }

      const footer = node.querySelector(".card-footer");
      if (footer){
        const hasVisibleChild = Array.from(footer.children).some(child => !child.hasAttribute("hidden") && child.textContent.trim() !== "");
        if (hasVisibleChild){
          footer.removeAttribute("hidden");
        }else{
          footer.setAttribute("hidden", "");
        }
      }

      const backEl = node.querySelector("[data-back]");
      renderBackContent(backEl, c);

      // Flip handlers
      node.querySelectorAll("[data-flip]").forEach(btn => {
        btn.addEventListener("click", () => {
          const flipped = root.getAttribute("data-flipped")==="1" ? "0" : "1";
          root.setAttribute("data-flipped", flipped);
        });
      });

      // Also flip by clicking anywhere on the card except links/buttons
      node.querySelector(".card-inner").addEventListener("click", (e) => {
        if (e.target.closest("button,a")) return;
        const flipped = root.getAttribute("data-flipped")==="1" ? "0" : "1";
        root.setAttribute("data-flipped", flipped);
      });

      frag.appendChild(node);
    }
    elCards.appendChild(frag);
    elMeta.textContent = `Cards: ${list.length} • Total: ${ALL_CARDS.length} • Presets: ${PRESETS.length}`;
    scheduleCardBalance();
  }

  function applyFilters(){
    const q = normalize(elQ.value);
    const presetId = elPreset.value;
    let base = [...ALL_CARDS];

    if (presetId) {
      const preset = PRESETS.find(p => p.id === presetId);
      const set = new Set((preset?.cards)||[]);
      base = base.filter(c => set.has(c.id));
    }

    if (q) {
      base = base.filter(c => {
        const hay = [
          c.title, c.quote, c.author, c.body, c.family, c.type,
          c.tagline, c.why, c.reflection,
          ...(c.how || []),
          ...(c.related || []),
          ...(c.audiences || []),
          ...(c.tags || [])
        ].map(normalize).join(" • ");
        return hay.includes(q);
      });
    }

    CURRENT = base;
    renderCards(CURRENT);

    const next = new URL(location);
    if (presetId) next.searchParams.set("preset", presetId); else next.searchParams.delete("preset");
    if (q) next.searchParams.set("q", q); else next.searchParams.delete("q");
    history.replaceState({}, "", next);
  }

  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }

  // Events
  document.getElementById("preset").addEventListener("change", applyFilters);
  document.getElementById("q").addEventListener("input", applyFilters);
  document.getElementById("shuffle").addEventListener("click", () => { shuffle(CURRENT); renderCards(CURRENT); });
  elStackPresent.addEventListener("click", () => startPresentation(0));
  elStackClear.addEventListener("click", clearStack);
  elPresentationPrev.addEventListener("click", () => changePresentation(-1));
  elPresentationNext.addEventListener("click", () => changePresentation(1));
  elPresentationFlip.addEventListener("click", () => { presentationFlipped = !presentationFlipped; updatePresentation(); });
  elPresentationClose.addEventListener("click", closePresentation);
  elPresentation.addEventListener("click", (event) => { if (event.target === elPresentation) closePresentation(); });
  window.addEventListener("resize", scheduleCardBalance);
  window.addEventListener("load", scheduleCardBalance);

  // Boot
  (async function init(){
    try{
      const [cards, presets] = await Promise.all([
        fetchJSON(CARDS_URL),
        fetchJSON(PRESETS_URL).catch(()=>[])
      ]);
      ALL_CARDS = Array.isArray(cards)?cards:[];
      PRESETS = Array.isArray(presets)?presets:[];
      PRESETS.forEach(p => {
        const opt=document.createElement("option"); opt.value=p.id; opt.textContent=p.name||p.id; elPreset.appendChild(opt);
      });

      const initPreset = qs.get("preset"); const initQ = qs.get("q");
      if (initPreset) document.getElementById("preset").value = initPreset;
      if (initQ) document.getElementById("q").value = initQ;

      loadStack();
      renderStack();

      applyFilters();
    }catch(e){
      elMeta.textContent = `Error: ${e.message}`;
      elCards.innerHTML = `<p class="text-red-700">Failed to load JSON from ${JSON_BASE}.</p>`;
    }
  })();
</script>
</body>
</html>

